import { Settings } from './SettingsPanel';
import { Recipe } from './RecipesPanel';
import { Buffer } from 'buffer';
import Pako from 'pako';

export type BlueprintOutput = {
	blueprintString: string;
	blueprintObject: any;
};

export function generateBlueprint(selectedRecipes: Recipe[], settings: Settings): BlueprintOutput {
	const {
		machineName,
		machineWidth,
		machineHeight,
		machineSpeed,
		rowLength,
		machineSpace,
		rowSpace,
		sourceChestName,
		requestFromBuffers,
		sourceChestWidth,
		sourceChestHeight,
		targetChestName,
		targetChestSetRequest,
		targetChestWidth,
		targetChestHeight,
		inserterName,
		outserterName,
		requestStackLimit,
		craftStackLimit,
	} = settings;

	const bpObject = {
		blueprint: {
			description:
				'This blueprint was generated by this site:\nhttps://jensforstmann.github.io/factorio-make-everything-generator/\n\nReport bugs & issues or make suggestions at:\nhttps://github.com/JensForstmann/factorio-make-everything-generator',
			icons: [
				{
					signal: {
						type: 'virtual',
						name: 'signal-M',
					},
					index: 1,
				},
				{
					signal: {
						type: 'virtual',
						name: 'signal-E',
					},
					index: 2,
				},
				{
					signal: {
						type: 'virtual',
						name: 'signal-black',
					},
					index: 3,
				},
				{
					signal: {
						type: 'virtual',
						name: 'signal-black',
					},
					index: 4,
				},
			],
			entities: [],
			item: 'blueprint',
			label: 'Factorio-Make-Everything',
			version: 281474976710656,
		},
	};

	const entities: any[] = bpObject.blueprint.entities;

	for (let i = 0; i < selectedRecipes.length; i++) {
		const recipe = selectedRecipes[i];

		const row = Math.floor(i / rowLength);
		const machineInRow = i % rowLength;

		const x =
			machineInRow *
			(machineSpace + Math.max(machineWidth, sourceChestWidth + targetChestWidth));
		const y =
			row * (machineHeight + rowSpace + Math.max(sourceChestHeight + targetChestHeight));

		const machine = {
			entity_number: 5 * i + 1,
			name: machineName,
			position: {
				x: x + machineWidth / 2,
				y: y + machineHeight / 2,
			},
			recipe: recipe.name,
		};

		const inserter = {
			entity_number: 5 * i + 2,
			name: inserterName,
			position: {
				x: x + 0.5,
				y: y + machineHeight + 0.5,
			},
			direction: 4,
		};

		const outserter = {
			entity_number: 5 * i + 3,
			name: outserterName,
			position: {
				x: x + 0.5 + sourceChestWidth,
				y: y + machineHeight + 0.5,
			},
		} as any;
		if (recipe.main_product && recipe.main_product_stack_size) {
			outserter.control_behavior = {
				logistic_condition: {
					first_signal: {
						type: 'item',
						name: recipe.main_product,
					},
					constant: recipe.main_product_stack_size * craftStackLimit,
					comparator: '<',
				},
				connect_to_logistic_network: true,
			};
		}

		const sourceChest = {
			entity_number: 5 * i + 4,
			name: sourceChestName,
			position: {
				x: x + sourceChestWidth / 2,
				y: y + machineHeight + 1 + sourceChestHeight / 2,
			},
			request_filters: recipe.item_ingredients.map((ing, i) => {
				const count = ing.count;
				const name = ing.name;
				const stack_size = ing.stack_size;
				const requestCount = Math.max(
					1,
					Math.floor(
						Math.min(
							stack_size * requestStackLimit,
							Math.max(
								count,
								(count * recipe.request_paste_multiplier * machineSpeed) /
									recipe.energy
							)
						)
					)
				);
				return {
					index: i + 1,
					name: name,
					count: requestCount,
				};
			}),
			request_from_buffers: requestFromBuffers,
		};

		const targetChest = {
			entity_number: 5 * i + 5,
			name: targetChestName,
			position: {
				x: x + sourceChestWidth + targetChestWidth / 2,
				y: y + machineHeight + 1 + targetChestHeight / 2,
			},
		};

		if (targetChestSetRequest && recipe.main_product) {
			(targetChest as any).request_filters = [
				{
					index: 1,
					name: recipe.main_product,
					count: 50000,
				},
			];
		}

		entities.push(machine);
		entities.push(inserter);
		entities.push(outserter);
		entities.push(sourceChest);
		entities.push(targetChest);
	}
	return {
		blueprintObject: bpObject,
		blueprintString:
			'0' +
			Buffer.from(
				Pako.deflate(new TextEncoder().encode(JSON.stringify(bpObject)), { level: 9 })
			).toString('base64'),
	};
}
